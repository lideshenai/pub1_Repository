算法介绍:
	1.将一个数学运算式先解析成有序的(方便增删替换的)符号组,容器自己写.
		所谓符号,一切数字和数学字符统称为符号.-1.4可以是两个符号,也可以是一个符号,还可以是3个符号.由解析决定.
	2.利用字符解析器解析数字,把结果替换到容器 .
		a.实例符号管理器,把所有符号注册到符号管理器中.
		b.对文本去空后 ,遍历 符号和文本, 通过Sign的boolean isMe(char) 判断是否属于某符号对象,实例符号对象并装入符号容器.
		c.遍历符号容器,发现有多个连接在一起的Sign instanceof Num 就直接处理----- 截取成子字符容器,解析,取有效值后拼接成字符串,解析成Sign,
			将新的Sign替换子符号容器.
	3.利用字符解析器继续深度解析(括号和运算符和小数点是非终结字符,数字自然是终结字符,小数点的优先级最高,标记为10000,小括号次高,标记为1000, +- 10 ,*/ 100)
		a.深度解析规则: 
			 A. 构造一个表达式对象,开始解析.非终结字符和终结字符相连就可以继续解析.非终结字符标记为当前非终结字符.当前非终结字符前面的字符组标
			 记为before,后面的标记为later.
					eg: 5+4 5为before, 当前非终结字符为+,later为4.
			 B.下一个非终结字符出现后,比较当前非终结字符和下一个非终结字符的优先级UnTerminalSign:  int getPrority()如果当前优先级不低于下一
					个,那么 结束当前表达式对象的处理,在构造下一个表达式对象. 将当前表达式对象作为下一个表达式对象的bef,nex(下一个非终结字符)作
					为下一个表达式的cur,寻找lat,重复步骤A. -----说明:cur,bef,lat.(cur:currentU.. 当前非终结字符,bef:before,lat:later);
					eg: 5+4-   ---- 封装该子字符容器入表达式对象 Expression.;  Expression next.bef = 封装好的那个Expression
			 C.如果下一个非终结字符优先级高,则办判断 UnTerminalSign: boolean isDouble(); 
			 	不是:则 新建一个Expression,将其引用交给 之前Expression的lat,而上一个原本那个lat交给新Expression的bef,
			 		nex作为新E的cur.继续步骤A;
						eg: 5+4* ... *优先级高于+,于是 抛弃5+, 留下4* , 再从第A开始寻找lat和nex(下一个非终结字符)
				若是:则构造个新Exp,其引用作为旧Exp的lat,标记该前括号,-- 向后寻找对应的后括号.中间的符号队列 存入 in 中;
						eg: 8*(3+4*3)  3+4*2 就是新Exp 的 in 属性, 旧Exp.lat = 新Exp
						
			 		
	4.迭代计算