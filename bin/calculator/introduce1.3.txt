算法介绍:
	1.将一个数学运算式先解析成有序的(方便增删替换的)符号组,容器自己写.
		所谓符号,一切数字和数学字符统称为符号.-1.4可以是两个符号,也可以是一个符号,还可以是3个符号.由解析决定.
	2.利用字符解析器解析数字,把结果替换到容器 .
		a.实例符号管理器,把所有符号注册到符号管理器中.
		b.对文本去空后 ,遍历 符号和文本, 通过Sign的boolean isMe(char) 判断是否属于某符号对象,实例符号对象并装入符号容器.
		c.遍历符号容器,发现有多个连接在一起的Sign instanceof Num 就直接处理----- 截取成子字符容器,解析,取有效值后拼接成字符串,解析成Sign,
			将新的Sign替换子符号容器.
	3.利用字符解析器继续深度解析
		a.深度解析规则:(括号和运算符和小数点是非终结字符,数字自然是终结字符,小数点的优先级最高,标记为10000,小括号次高,标记为1000, +- 10 ,*/ 100)
			 A. 开始解析. 构造一个表达式对象(用字符容器构造)非终结字符和终结字符相连就可以继续解析.非终结字符标记为当前非终结字符.当前非终结字符前面的字符组标
			 记为before,后面的标记为later.
					eg: 5+4 5为before, 当前非终结字符为+,later为4.
			 B.下一个非终结字符出现后,比较当前非终结字符和下一个非终结字符的优先级UnTerminalSign:  int getPrority()如果当前优先级不低于下一
					个,那么  截取成子字符容器   .计算当前表达式,计算方式为获取当前非终结字符的算法,传入bef,lat,计算.计算结果替换子字符容器.从字符容器头开始重复
					步骤A.
			 C.如果下一个非终结字符优先级高,那么检查  (instanceof Doubled) ;
			 	如果不是,抛弃bef 和 cur, lat 作为bef ,nextU 作为cur, 继续步骤Ａ．
						eg: 5+4* ... *优先级高于+,于是抛弃5+, 留下4* , 再从第A开始寻找lat和nex(下一个非终结字符)
			 	如果是,寻找与之对应的最近一个成对符号( Doubled: getDoubleCount();),为了分析出左右括号,规定左为偶数整十,右为左+1.一开始就是右或找
			 	不到右,抛语法异常.倒置截下括号内的的子字符容器(计数器) 构造一个新的表达式对象,用该表达式对象替换子字符容器.表达式对象 继承Num对象,重写其
			 	getValue()方法.为了让大小中括号有序,添加方法(Expression :　double getPrority(); void setPrority(double prority)),prority 的值为左括号的值,
			 	默认为0:表示表达式没有括号.10表示持有小括号,100持有中,1000持有大括号.如果发现获取到的左括号的优先级小与表达式优先级,抛语法异常.依照数字的方式
			 	设置,存在bef,则设置为lat,
			 		eg: 5*(4
			 		
			 		4*(5+3*2);   4+(3*7)+5*3;
	4.迭代计算